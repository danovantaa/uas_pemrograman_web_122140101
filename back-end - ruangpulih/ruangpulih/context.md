## File: `ruangpulih\alembic\env.py`

```
"""Pyramid bootstrap environment. """
from alembic import context
from pyramid.paster import get_appsettings, setup_logging
from sqlalchemy import engine_from_config

from ruangpulih.models.meta import Base

config = context.config

setup_logging(config.config_file_name)

settings = get_appsettings(config.config_file_name)
target_metadata = Base.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    context.configure(url=settings['sqlalchemy.url'])
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(settings, prefix='sqlalchemy.')

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

## File: `ruangpulih\alembic\script.py.mako`

```
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

```

## File: `ruangpulih\alembic\versions\20250524_0f0bff5f685f.py`

```
"""init kedua

Revision ID: 0f0bff5f685f
Revises: 88291d9da7f4
Create Date: 2025-05-24 13:22:05.103489

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0f0bff5f685f'
down_revision = '88291d9da7f4'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

```

## File: `ruangpulih\alembic\versions\20250524_88291d9da7f4.py`

```
"""Initial schema setup with SQLAlchemy Enum for User role

Revision ID: 88291d9da7f4
Revises:
Create Date: 2025-05-24 12:02:10.024630

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '88291d9da7f4'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('username', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('password', sa.String(), nullable=False),
    sa.Column('role', sa.Enum('client', 'psychologist', name='role_enum'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),
    sa.UniqueConstraint('email', name=op.f('uq_users_email')),
    sa.UniqueConstraint('username', name=op.f('uq_users_username'))
    )
    op.create_table('schedules',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('psychologist_id', sa.String(), nullable=True),
    sa.Column('date', sa.Date(), nullable=False),
    sa.Column('time_slot', sa.Time(), nullable=False),
    sa.Column('is_booked', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['psychologist_id'], ['users.id'], name=op.f('fk_schedules_psychologist_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_schedules'))
    )
    op.create_table('bookings',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('client_id', sa.String(), nullable=True),
    sa.Column('schedule_id', sa.String(), nullable=True),
    sa.Column('status', sa.Enum('pending', 'confirmed', 'rejected', name='booking_status'), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['client_id'], ['users.id'], name=op.f('fk_bookings_client_id_users')),
    sa.ForeignKeyConstraint(['schedule_id'], ['schedules.id'], name=op.f('fk_bookings_schedule_id_schedules')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_bookings'))
    )
    op.create_table('reviews',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('booking_id', sa.String(), nullable=False),
    sa.Column('rating', sa.Integer(), nullable=False),
    sa.Column('comment', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['booking_id'], ['bookings.id'], name=op.f('fk_reviews_booking_id_bookings')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_reviews'))
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('reviews')
    op.drop_table('bookings')
    op.drop_table('schedules')
    op.drop_table('users')
    # ### end Alembic commands ###

```

## File: `ruangpulih\alembic\versions\README.txt`

```
Placeholder for alembic versions
```

## File: `ruangpulih\models\booking.py`

```
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Enum, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from .meta import Base

class Booking(Base):
    __tablename__ = 'bookings'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    client_id = Column(String, ForeignKey('users.id'))
    schedule_id = Column(String, ForeignKey('schedules.id'))
    status = Column(Enum("pending", "confirmed", "rejected", name="booking_status"), default="pending")
    created_at = Column(DateTime, default=datetime.utcnow)

    client = relationship("User", back_populates="bookings")
    schedule = relationship("Schedule", back_populates="bookings")

    def to_dict(self):
        data = {
            "id": self.id,
            "client_id": self.client_id,
            "schedule_id": self.schedule_id,
            "status": self.status,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }

        if self.client:
            data['client_details'] = self.client.to_dict()

        return data

    def __repr__(self):
        return (
            f"<Booking(id='{self.id}', client_id='{self.client_id}', "
            f"schedule_id='{self.schedule_id}', status='{self.status}')>"
        )

```

## File: `ruangpulih\models\meta.py`

```
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.schema import MetaData

# Recommended naming convention used by Alembic, as various different database
# providers will autogenerate vastly different names making migrations more
# difficult. See: http://alembic.zzzcomputing.com/en/latest/naming.html
NAMING_CONVENTION = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

metadata = MetaData(naming_convention=NAMING_CONVENTION)
Base = declarative_base(metadata=metadata)

```

## File: `ruangpulih\models\review.py`

```
import uuid
from sqlalchemy import Column, String, Text, ForeignKey, Integer
from sqlalchemy.orm import relationship
from .meta import Base

class Review(Base):
    __tablename__ = 'reviews'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    booking_id = Column(String, ForeignKey('bookings.id'), nullable=False)
    rating = Column(Integer, nullable=False)
    comment = Column(Text)

    booking = relationship("Booking")

    def to_dict(self):
        return {
            "id": self.id,
            "booking_id": self.booking_id,
            "rating": self.rating,
            "comment": self.comment
        }

    def __repr__(self):
        return (
            f"<Review(id='{self.id}', booking_id='{self.booking_id}', "
            f"rating='{self.rating}')>"
        )

```

## File: `ruangpulih\models\schedule.py`

```
import uuid
from sqlalchemy import Column, String, Date, Time, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from .meta import Base

class Schedule(Base):
    __tablename__ = 'schedules'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    psychologist_id = Column(String, ForeignKey('users.id'))
    date = Column(Date, nullable=False)
    time_slot = Column(Time, nullable=False)
    is_booked = Column(Boolean, default=False)

    psychologist = relationship("User", back_populates="schedules")
    bookings = relationship("Booking", back_populates="schedule", uselist=True, cascade="all, delete-orphan")

    def to_dict(self):
        data = {
            "id": self.id,
            "psychologist_id": self.psychologist_id,
            "date": self.date.isoformat(),
            "time_slot": self.time_slot.strftime('%H:%M'),
            "is_booked": self.is_booked
        }

        # Find the current active booking if the schedule is booked.
        # This assumes a schedule typically has one 'active' booking at a time.
        # You might need to refine the filtering logic if there are multiple bookings
        # and you need a specific one (e.g., 'confirmed' status, or latest).
        current_booking = None
        if self.is_booked and self.bookings:
            current_booking = next((b for b in self.bookings if b.status == 'confirmed'), None)
            if not current_booking:
                current_booking = self.bookings[0]

        if current_booking:
            data['current_booking'] = current_booking.to_dict()

        return data

    def __repr__(self):
        return (
            f"<Schedule(id='{self.id}', psychologist_id='{self.psychologist_id}', "
            f"date='{self.date}', time_slot='{self.time_slot}', booked={self.is_booked})>"
        )

```

## File: `ruangpulih\models\user.py`

```
import uuid
from sqlalchemy import Column, String, Enum
from sqlalchemy.orm import relationship
from passlib.hash import bcrypt
from .meta import Base

class User(Base):
    __tablename__ = 'users'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    username = Column(String, nullable=False, unique=True)
    email = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=False)

    role = Column(
        Enum("client", "psychologist", name="role_enum"),
        nullable=False
    )

    schedules = relationship("Schedule", back_populates="psychologist")
    bookings = relationship("Booking", back_populates="client")

    def set_password(self, raw_password):
        self.password = bcrypt.hash(raw_password)

    def check_password(self, raw_password):
        return bcrypt.verify(raw_password, self.password)

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "role": self.role
        }

    def __repr__(self):
        return f"<User(username='{self.username}', email='{self.email}', role='{self.role}')>"

```

## File: `ruangpulih\models\__init__.py`

```
from sqlalchemy import engine_from_config
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import configure_mappers
import zope.sqlalchemy

# Import all models to ensure they are attached to the Base.metadata
from .booking import Booking
from .review import Review
from .schedule import Schedule
from .user import User

# Run configure_mappers after defining all models to ensure relationships are set up
configure_mappers()

def get_engine(settings, prefix='sqlalchemy.'):
    return engine_from_config(settings, prefix)

def get_session_factory(engine):
    factory = sessionmaker()
    factory.configure(bind=engine)
    return factory

def get_tm_session(session_factory, transaction_manager):
    """
    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.

    This function will hook the session to the transaction manager which
    will take care of committing any changes.

    - When using pyramid_tm it will automatically be committed or aborted
      depending on whether an exception is raised.

    - When using scripts you should wrap the session in a manager yourself.
      For example::

          import transaction

          engine = get_engine(settings)
          session_factory = get_session_factory(engine)
          with transaction.manager:
              dbsession = get_tm_session(session_factory, transaction.manager)
    """
    dbsession = session_factory()
    zope.sqlalchemy.register(
        dbsession, transaction_manager=transaction_manager)
    return dbsession

def includeme(config):
    """
    Initialize the model for a Pyramid app.

    Activate this setup using ``config.include('ruangpulih.models')``.
    """
    settings = config.get_settings()
    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'

    config.include('pyramid_tm')
    config.include('pyramid_retry')

    session_factory = get_session_factory(get_engine(settings))
    config.registry['dbsession_factory'] = session_factory

    config.add_request_method(
        lambda r: get_tm_session(session_factory, r.tm),
        'dbsession',
        reify=True
    )

```

## File: `ruangpulih\scripts\initialize_db.py`

```
import os
import argparse
import sys
import transaction
import uuid
from datetime import datetime, date, time

from pyramid.paster import bootstrap, setup_logging
from sqlalchemy.exc import OperationalError

from .. import models
from ..models.meta import Base
from ..models.user import User
from ..models.schedule import Schedule
from ..models.booking import Booking
from ..models.review import Review

def setup_models(dbsession):
    """
    Initializes database tables and adds dummy data.
    """
    print("Creating all tables based on models...")
    Base.metadata.create_all(dbsession.bind)
    print("Tables successfully created.")

    print("Adding dummy data...")

    # 1. Users (Psychologists and Clients)
    psychologist_lisa = User(
        id=str(uuid.uuid4()),
        username="dr.lisa",
        email="lisa@ruangpulih.com",
        role="psychologist"
    )
    psychologist_lisa.set_password("passwordlisa")
    dbsession.add(psychologist_lisa)

    psychologist_budi = User(
        id=str(uuid.uuid4()),
        username="dr.budi",
        email="budi@ruangpulih.com",
        role="psychologist"
    )
    psychologist_budi.set_password("passwordbudi")
    dbsession.add(psychologist_budi)

    client_ali = User(
        id=str(uuid.uuid4()),
        username="ali_client",
        email="ali@example.com",
        role="client"
    )
    client_ali.set_password("passwordali")
    dbsession.add(client_ali)

    client_bina = User(
        id=str(uuid.uuid4()),
        username="bina_client",
        email="bina@example.com",
        role="client"
    )
    client_bina.set_password("passwordbina")
    dbsession.add(client_bina)

    dbsession.flush()

    # 2. Schedules
    schedule_lisa_1 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_lisa.id,
        date=date(2025, 6, 1),
        time_slot=time(9, 0),
        is_booked=False
    )
    dbsession.add(schedule_lisa_1)

    schedule_lisa_2 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_lisa.id,
        date=date(2025, 6, 1),
        time_slot=time(10, 0),
        is_booked=False
    )
    dbsession.add(schedule_lisa_2)

    schedule_budi_1 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_budi.id,
        date=date(2025, 6, 2),
        time_slot=time(14, 0),
        is_booked=False
    )
    dbsession.add(schedule_budi_1)

    schedule_budi_2 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_budi.id,
        date=date(2025, 6, 2),
        time_slot=time(15, 0),
        is_booked=False
    )
    dbsession.add(schedule_budi_2)

    dbsession.flush()

    # 3. Bookings
    booking_ali_lisa = Booking(
        id=str(uuid.uuid4()),
        client_id=client_ali.id,
        schedule_id=schedule_lisa_1.id,
        status="confirmed",
        created_at=datetime.utcnow()
    )
    dbsession.add(booking_ali_lisa)
    schedule_lisa_1.is_booked = True

    booking_bina_budi = Booking(
        id=str(uuid.uuid4()),
        client_id=client_bina.id,
        schedule_id=schedule_budi_1.id,
        status="pending",
        created_at=datetime.utcnow()
    )
    dbsession.add(booking_bina_budi)
    schedule_budi_1.is_booked = True

    dbsession.flush()

    # 4. Reviews
    review_ali = Review(
        id=str(uuid.uuid4()),
        booking_id=booking_ali_lisa.id,
        rating=5,
        comment="Sesi yang sangat membantu dan insightful. Terima kasih dr. Lisa!"
    )
    dbsession.add(review_ali)

    print("Dummy data successfully added.")


def parse_args(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'config_uri',
        help='Configuration file, e.g., development.ini',
    )
    return parser.parse_args(argv[1:])


def main(argv=sys.argv):
    args = parse_args(argv)
    setup_logging(args.config_uri)
    env = bootstrap(args.config_uri)

    try:
        with env['request'].tm:
            dbsession = env['request'].dbsession
            setup_models(dbsession)
            transaction.commit()
            print("Database initialization complete.")
    except OperationalError:
        print('''
Pyramid is having a problem using your SQL database. The problem
might be caused by one of the following things:

1.  You may need to initialize your database tables with `alembic upgrade head`.
    This script (`initialize_db.py`) is for initial data population
    after the schema is created by Alembic.

2.  Your database server may not be running. Check that the
    database server referred to by the "sqlalchemy.url" setting in
    your "development.ini" file is running.
        ''')
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred during database initialization: {e}")
        transaction.abort()
        sys.exit(1)

```

## File: `ruangpulih\scripts\__init__.py`

```
# package

```

## File: `ruangpulih\views\auth.py`

```
from pyramid.view import view_config
from pyramid.response import Response
from pyramid.httpexceptions import HTTPBadRequest, HTTPConflict, HTTPUnauthorized
from pyramid.security import remember, forget
from ..models.user import User
from uuid import uuid4

def require_fields(data, required_fields):
    """Helper function to validate required fields in request data."""
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

@view_config(route_name='register', request_method='POST', renderer='json')
def register(request):
    """Handles new user registration."""
    data = request.json_body

    try:
        require_fields(data, ['username', 'email', 'password', 'role'])
    except HTTPBadRequest as e:
        return e

    username = data['username']
    email = data['email']
    password = data['password']
    role_str = data['role']

    valid_roles = ["client", "psychologist"]
    if role_str not in valid_roles:
        return HTTPBadRequest(json_body={'error': f'Invalid role: {role_str}. Valid roles are: {", ".join(valid_roles)}'})

    if request.dbsession.query(User).filter_by(username=username).first():
        return HTTPConflict(json_body={'error': 'Username already exists'})
    if request.dbsession.query(User).filter_by(email=email).first():
        return HTTPConflict(json_body={'error': 'Email already exists'})

    new_user = User(
        id=str(uuid4()),
        username=username,
        email=email,
        role=role_str
    )

    new_user.set_password(password)
    request.dbsession.add(new_user)

    return {
        'message': 'Registration successful',
        'user': new_user.to_dict()
    }

@view_config(route_name='login', request_method='POST', renderer='json')
def login(request):
    """Handles user login."""
    data = request.json_body

    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e:
        return e

    email = data['email']
    password = data['password']
    user = request.dbsession.query(User).filter_by(email=email).first()

    if not user or not user.check_password(password):
        return HTTPUnauthorized(json_body={'error': 'Invalid credentials'})

    headers = remember(request, user.id)

    return Response(
        json_body={
            'message': 'Login successful',
            'user': user.to_dict()
        },
        headers=headers,
        content_type='application/json'
    )

@view_config(route_name='logout', request_method='POST', renderer='json')
def logout(request):
    """Handles user logout."""
    headers = forget(request)
    return Response(
        json_body={'message': 'Logout successful'},
        headers=headers,
        content_type='application/json'
    )

```

## File: `ruangpulih\views\bookings.py`

```
from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized, HTTPNotFound
from pyramid.view import view_config
from sqlalchemy.orm import joinedload
from ..models.booking import Booking
from ..models.schedule import Schedule
from ..models.user import User
import uuid
from datetime import datetime

def get_user_id(request):
    """Extracts and validates the authenticated user ID from the request."""
    user_id = request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json_body={"error": "Unauthorized"})
    return user_id

def get_schedule_or_404(request, schedule_id):
    """Fetches a schedule by ID or raises HTTPNotFound."""
    schedule = request.dbsession.get(Schedule, schedule_id)
    if not schedule:
        raise HTTPNotFound(json_body={"error": "Schedule not found"})
    return schedule

@view_config(route_name='bookings', request_method='GET', renderer='json')
def list_bookings(request):
    """
    Lists bookings based on the authenticated user's role.
    Clients see their own bookings.
    Psychologists see bookings for their schedules.
    """
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    bookings_query = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    )

    if user.role == 'client':
        bookings_query = bookings_query.filter(Booking.client_id == user_id)
    elif user.role == 'psychologist':
        bookings_query = bookings_query.join(Schedule).filter(Schedule.psychologist_id == user_id)
    else:
        raise HTTPUnauthorized(json_body={"error": "Access denied for this role"})

    bookings = bookings_query.all()
    return [b.to_dict() for b in bookings]

@view_config(route_name='bookings', request_method='POST', renderer='json')
def create_booking(request):
    """Allows clients to create a new booking for an available schedule."""
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    if not user or user.role != 'client':
        raise HTTPUnauthorized(json_body={"error": "Only clients can create bookings"})

    data = request.json_body
    schedule_id = data.get("schedule_id")

    schedule = request.dbsession.query(Schedule).options(
        joinedload(Schedule.bookings)
    ).get(schedule_id)

    if not schedule:
        raise HTTPNotFound(json_body={"error": "Schedule not found"})

    if schedule.is_booked:
        raise HTTPBadRequest(json_body={"error": "Schedule already booked"})

    booking = Booking(
        id=str(uuid.uuid4()),
        client_id=user_id,
        schedule_id=schedule_id,
        status="pending",
        created_at=datetime.utcnow()
    )

    schedule.is_booked = True

    request.dbsession.add(booking)
    request.dbsession.flush()

    created_booking = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking.id)

    return created_booking.to_dict()

@view_config(route_name='booking_detail', request_method='GET', renderer='json')
def get_booking(request):
    """
    Retrieves details of a specific booking.
    Authorization: Clients can view their own, psychologists can view bookings for their schedules.
    """
    booking_id = request.matchdict['id']
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    booking = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking_id)

    if not booking:
        raise HTTPNotFound(json_body={"error": "Booking not found"})

    if user.role == 'client' and booking.client_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to view this booking"})
    elif user.role == 'psychologist' and booking.schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to view this booking"})

    return booking.to_dict()

@view_config(route_name='booking_detail', request_method='PUT', renderer='json')
@view_config(route_name='booking_detail', request_method='PATCH', renderer='json')
def update_booking_status(request):
    """
    Updates the status of a booking.
    Authorization: Clients can cancel their own bookings.
    Psychologists can confirm/reject bookings for their schedules.
    """
    booking_id = request.matchdict['id']
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    booking = request.dbsession.query(Booking).options(
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking_id)

    if not booking:
        raise HTTPNotFound(json_body={"error": "Booking not found"})

    new_status = request.json_body.get('status')
    if not new_status:
        raise HTTPBadRequest(json_body={"error": "Status field is required."})

    if user.role == 'client':
        if booking.client_id != user_id:
            raise HTTPUnauthorized(json_body={"error": "You do not have permission to modify this booking"})

        if new_status != "rejected":
            raise HTTPBadRequest(json_body={"error": "Clients can only cancel their bookings (set status to 'rejected')."})

        if booking.status != 'pending':
            raise HTTPBadRequest(json_body={"error": "Only pending bookings can be cancelled by clients."})

    elif user.role == 'psychologist':
        if booking.schedule.psychologist_id != user_id:
            raise HTTPUnauthorized(json_body={"error": "You do not have permission to modify this booking"})

        if new_status not in ["pending", "confirmed", "rejected"]:
            raise HTTPBadRequest(json_body={"error": "Invalid status provided."})

        if booking.status == 'confirmed' and new_status == 'pending':
            raise HTTPBadRequest(json_body={"error": "Cannot change confirmed booking back to pending."})
        if booking.status == 'rejected' and new_status != 'rejected':
            raise HTTPBadRequest(json_body={"error": "Cannot change rejected booking status."})
    else:
        raise HTTPUnauthorized(json_body={"error": "Access denied for this role"})

    booking.status = new_status

    if new_status == 'confirmed':
        booking.schedule.is_booked = True
    elif new_status == 'rejected':
        booking.schedule.is_booked = False
    elif new_status == 'pending' and not booking.schedule.is_booked:
        booking.schedule.is_booked = True

    request.dbsession.flush()

    updated_booking = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking_id)

    return updated_booking.to_dict()

@view_config(route_name='booking_detail', request_method='DELETE', renderer='json')
def delete_booking(request):
    """
    Deletes a booking.
    Authorization: Clients can delete their own bookings.
    Psychologists can delete any booking on their schedules.
    """
    booking_id = request.matchdict['id']
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    booking = request.dbsession.query(Booking).options(
        joinedload(Booking.schedule)
    ).get(booking_id)

    if not booking:
        raise HTTPNotFound(json_body={"error": "Booking not found"})

    if user.role == 'client' and booking.client_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to delete this booking"})
    elif user.role == 'psychologist' and booking.schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to delete this booking"})

    booking.schedule.is_booked = False

    request.dbsession.delete(booking)
    return {"message": "Booking deleted successfully"}

```

## File: `ruangpulih\views\default.py`

```
from pyramid.response import Response
from pyramid.view import view_config

@view_config(route_name='home')
def home_view(request):
    return Response('Ruang Pulih API Home', content_type='text/plain')

```

## File: `ruangpulih\views\notfound.py`

```
from pyramid.view import notfound_view_config


@notfound_view_config(renderer='../templates/404.jinja2')
def notfound_view(request):
    request.response.status = 404
    return {}

```

## File: `ruangpulih\views\pyschologist.py`

```
from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized, HTTPNotFound
from pyramid.view import view_config
from sqlalchemy.orm import joinedload, subqueryload
from sqlalchemy import and_, func
from ..models.user import User
from ..models.schedule import Schedule
from ..models.booking import Booking
from ..models.review import Review
from datetime import datetime, date, time

def psychologist_to_dict(psychologist, average_rating=None, total_reviews=None, available_schedules=None):
    """Helper function to format psychologist details into a dictionary."""
    data = {
        'id': str(psychologist.id),
        'username': psychologist.username,
        'email': psychologist.email,
        'role': psychologist.role,
        'average_rating': average_rating,
        'total_reviews': total_reviews,
    }
    if available_schedules is not None:
        data['available_schedules'] = available_schedules
    return data

def schedule_to_dict_simple(schedule):
    """Helper function to format schedule details simply."""
    return {
        'id': str(schedule.id),
        'date': schedule.date.isoformat(),
        'time_slot': schedule.time_slot.strftime('%H:%M'),
        'is_booked': schedule.is_booked,
    }

def review_to_dict_simple(review):
    """Helper function to format review details simply."""
    return {
        'id': str(review.id),
        'booking_id': review.booking_id,
        'rating': review.rating,
        'comment': review.comment,
    }

@view_config(route_name='psychologists_with_available_schedules', request_method='GET', renderer='json')
def get_psychologists_with_available_schedules(request):
    """
    Lists psychologists with their available (unbooked) schedules from today onwards.
    """
    today = datetime.utcnow().date()

    available_schedules_query = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist)
    ).filter(
        and_(
            Schedule.is_booked == False,
            Schedule.date >= today
        )
    ).order_by(
        Schedule.psychologist_id,
        Schedule.date,
        Schedule.time_slot
    )

    all_available_schedules = available_schedules_query.all()

    psychologists_data = {}
    for schedule in all_available_schedules:
        if schedule.psychologist:
            psychologist_id = str(schedule.psychologist.id)
            if psychologist_id not in psychologists_data:
                psychologists_data[psychologist_id] = psychologist_to_dict(schedule.psychologist)
                psychologists_data[psychologist_id]['available_schedules'] = []

            psychologists_data[psychologist_id]['available_schedules'].append(schedule_to_dict_simple(schedule))

    # Average rating and total reviews are not calculated here for the list view
    # as it might be performance-intensive for a large number of psychologists.
    # They are set to None/0 by default in psychologist_to_dict.
    return list(psychologists_data.values())

@view_config(route_name='psychologist_detail', request_method='GET', renderer='json')
def get_psychologist_detail(request):
    """
    Retrieves detailed information for a specific psychologist,
    including their available schedules and reviews.
    """
    psychologist_id = request.matchdict['id']

    psychologist = request.dbsession.query(User).filter(
        and_(User.id == psychologist_id, User.role == 'psychologist')
    ).first()

    if not psychologist:
        raise HTTPNotFound(json_body={"error": "Psychologist not found."})

    today = datetime.utcnow().date()
    available_schedules = request.dbsession.query(Schedule).filter(
        and_(
            Schedule.psychologist_id == psychologist_id,
            Schedule.is_booked == False,
            Schedule.date >= today
        )
    ).order_by(
        Schedule.date,
        Schedule.time_slot
    ).all()

    reviews_data = request.dbsession.query(Review).options(
        joinedload(Review.booking)
    ).join(Booking.schedule).filter(
        Schedule.psychologist_id == psychologist_id
    ).all()

    num_reviews = len(reviews_data)
    average_rating = round(sum(r.rating for r in reviews_data) / num_reviews, 1) if num_reviews > 0 else None

    psychologist_details = psychologist_to_dict(
        psychologist,
        average_rating=average_rating,
        total_reviews=num_reviews,
        available_schedules=[schedule_to_dict_simple(s) for s in available_schedules]
    )

    psychologist_details['reviews'] = [review_to_dict_simple(r) for r in reviews_data]

    return psychologist_details

```

## File: `ruangpulih\views\reviews.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPUnauthorized
from ..models.review import Review
from ..models.booking import Booking
import uuid

def get_user_id(request):
    user_id = request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json_body={"error": "Unauthorized"})
    return user_id

@view_config(route_name='reviews', request_method='POST', renderer='json')
def create_review(request):
    user_id = get_user_id(request)
    data = request.json_body
    booking_id = data.get("booking_id")
    rating = data.get("rating")
    comment = data.get("comment", "")

    booking = request.dbsession.get(Booking, booking_id)
    if not booking or booking.client_id != user_id:
        raise HTTPNotFound(json_body={"error": "Booking not found or not yours"})

    review = Review(
        id=str(uuid.uuid4()),
        booking_id=booking_id,
        rating=rating,
        comment=comment
    )
    request.dbsession.add(review)
    return review.to_dict()

@view_config(route_name='reviews', request_method='GET', renderer='json')
def list_reviews(request):
    reviews = request.dbsession.query(Review).all()
    return [r.to_dict() for r in reviews]

```

## File: `ruangpulih\views\schedules.py`

```
# File: views/schedules.py
from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized, HTTPNotFound
from pyramid.view import view_config
from sqlalchemy.orm import joinedload
from ..models.schedule import Schedule
from ..models.user import User
from ..models.booking import Booking
import uuid
from datetime import datetime

def get_user_id(request):
    user_id = request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json_body={"error": "Unauthorized"})
    return user_id

def get_schedule_or_404(request, schedule_id):
    schedule = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist),
        joinedload(Schedule.bookings).joinedload(Booking.client)
    ).get(schedule_id)

    if not schedule:
        raise HTTPNotFound(json_body={"error": "Schedule not found"})
    return schedule

@view_config(route_name='schedules', request_method='GET', renderer='json')
def list_schedules(request):
    schedules_query = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist),
        joinedload(Schedule.bookings).joinedload(Booking.client)
    )

    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    if user.role == 'psychologist':
        schedules_query = schedules_query.filter(Schedule.psychologist_id == user_id)

    schedules = schedules_query.all()
    return [s.to_dict() for s in schedules]

@view_config(route_name='schedules', request_method='POST', renderer='json')
def add_schedule(request):
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    if not user or user.role != 'psychologist':
        raise HTTPUnauthorized(json_body={"error": "Only psychologists can create schedules"})

    data = request.json_body
    try:
        date = datetime.strptime(data.get("date"), "%Y-%m-%d").date()
        time_slot = datetime.strptime(data.get("time_slot"), "%H:%M").time()
    except Exception:
        raise HTTPBadRequest(json_body={"error": "Invalid date or time format (date=YYYY-MM-DD, time=HH:MM)"})

    new_schedule = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=user_id,
        date=date,
        time_slot=time_slot,
        is_booked=False
    )
    request.dbsession.add(new_schedule)
    request.dbsession.flush()

    created_schedule = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist),
        joinedload(Schedule.bookings).joinedload(Booking.client)
    ).get(new_schedule.id)

    return created_schedule.to_dict()

@view_config(route_name='schedule_detail', request_method='GET', renderer='json')
def get_schedule(request):
    schedule_id = request.matchdict['id']
    schedule = get_schedule_or_404(request, schedule_id)
    return schedule.to_dict()

@view_config(route_name='schedule_detail', request_method='PUT', renderer='json')
def update_schedule(request):
    schedule_id = request.matchdict['id']
    user_id = get_user_id(request)
    schedule = get_schedule_or_404(request, schedule_id)

    if schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to edit this schedule"})

    data = request.json_body
    try:
        if 'date' in data:
            schedule.date = datetime.strptime(data['date'], "%Y-%m-%d").date()
        if 'time_slot' in data:
            schedule.time_slot = datetime.strptime(data['time_slot'], "%H:%M").time()
    except Exception:
        raise HTTPBadRequest(json_body={"error": "Invalid date or time format (date=YYYY-MM-DD, time=HH:MM)"})

    return schedule.to_dict()

@view_config(route_name='schedule_detail', request_method='DELETE', renderer='json')
def delete_schedule(request):
    schedule_id = request.matchdict['id']
    user_id = get_user_id(request)
    schedule = get_schedule_or_404(request, schedule_id)

    if schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to delete this schedule"})

    if schedule.is_booked:
        raise HTTPBadRequest(json_body={"error": "Cannot delete schedule that has been booked"})

    request.dbsession.delete(schedule)
    return {"message": "Schedule deleted"}

```

## File: `ruangpulih\views\__init__.py`

```

```

## File: `ruangpulih\cors.py`

```
# In a file called tweens.py or in the main file
from pyramid.response import Response
from pyramid.httpexceptions import HTTPForbidden

def cors_tween_factory(handler, registry):
    def cors_tween(request):
        # Allow specific origin (not *)
        allowed_origin = 'http://localhost:5173'

        if request.method == 'OPTIONS':
            # Preflight response
            response = request.response
            response.headers['Access-Control-Allow-Origin'] = allowed_origin
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            response.headers['Access-Control-Max-Age'] = '3600'

            return response

        # Actual response
        response = handler(request)
        response.headers['Access-Control-Allow-Origin'] = allowed_origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

        return response

    return cors_tween
```

## File: `ruangpulih\pshell.py`

```
from . import models

def setup(env):
    request = env['request']

    # start a transaction
    request.tm.begin()

    # inject some vars into the shell builtins
    env['tm'] = request.tm
    env['dbsession'] = request.dbsession
    env['models'] = models

```

## File: `ruangpulih\routes.py`

```
def includeme(config):
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')

    # Auth routes
    config.add_route('register', '/register')
    config.add_route('login', '/login')
    config.add_route('logout', '/logout')

    # Schedules routes
    config.add_route('schedules', '/schedules')                     # GET (list), POST (create)
    config.add_route('schedule_detail', '/schedules/{id}')          # GET (detail), PUT (update), DELETE (delete)

    # Bookings routes
    config.add_route('bookings', '/bookings')
    config.add_route('booking_detail', '/bookings/{id}')

    # Psychologists routes
    config.add_route('psychologists_with_available_schedules', '/psychologists/available')
    config.add_route('psychologist_detail', '/psychologists/{id}')

    # Reviews routes
    config.add_route('reviews', '/reviews')

```

## File: `ruangpulih\tests.py`

```
import unittest
import transaction

from pyramid import testing

def dummy_request(dbsession):
    return testing.DummyRequest(dbsession=dbsession)


class BaseTest(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp(settings={
            'sqlalchemy.url': 'sqlite:///:memory:'
        })
        self.config.include('.models')
        settings = self.config.get_settings()

        from .models import (
            get_engine,
            get_session_factory,
            get_tm_session,
            )

        self.engine = get_engine(settings)
        session_factory = get_session_factory(self.engine)

        self.session = get_tm_session(session_factory, transaction.manager)

    def init_database(self):
        from .models.meta import Base
        Base.metadata.create_all(self.engine)

    def tearDown(self):
        from .models.meta import Base

        testing.tearDown()
        transaction.abort()
        Base.metadata.drop_all(self.engine)


class TestMyViewSuccessCondition(BaseTest):

    def setUp(self):
        super(TestMyViewSuccessCondition, self).setUp()
        self.init_database()

        from .models import MyModel

        model = MyModel(name='one', value=55)
        self.session.add(model)

    def test_passing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info['one'].name, 'one')
        self.assertEqual(info['project'], 'ruangpulih')


class TestMyViewFailureCondition(BaseTest):

    def test_failing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info.status_int, 500)

```

## File: `ruangpulih\__init__.py`

```
from pyramid.config import Configurator
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from .cors import cors_tween_factory
from pyramid.renderers import JSON


def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application. """
    # Set authentication and authorization policies
    authn_policy = AuthTktAuthenticationPolicy(
        secret='supersecretvalue',  # Ganti dengan nilai rahasia Anda
        callback=None,  # Tidak ada callback untuk group/role karena Anda tidak memakai role
        hashalg='sha512'
    )

    authz_policy = ACLAuthorizationPolicy()  # Untuk authorization dasar

    with Configurator(settings=settings) as config:
        config.set_authentication_policy(authn_policy)  # Set authentication policy
        config.set_authorization_policy(authz_policy)  # Set authorization policy

        config.add_tween('.cors_tween_factory')  # Add CORS tween
        config.add_renderer('json', JSON(indent=4))

        config.include('pyramid_jinja2')
        config.include('.models')
        config.include('.routes')

        config.scan()  # Memindai semua view-config

    return config.make_wsgi_app()

```

## File: `ruangpulih\alembic\env.py`

```
"""Pyramid bootstrap environment. """
from alembic import context
from pyramid.paster import get_appsettings, setup_logging
from sqlalchemy import engine_from_config

from ruangpulih.models.meta import Base

config = context.config

setup_logging(config.config_file_name)

settings = get_appsettings(config.config_file_name)
target_metadata = Base.metadata


def run_migrations_offline():
    """Run migrations in 'offline' mode.

    This configures the context with just a URL
    and not an Engine, though an Engine is acceptable
    here as well.  By skipping the Engine creation
    we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.

    """
    context.configure(url=settings['sqlalchemy.url'])
    with context.begin_transaction():
        context.run_migrations()


def run_migrations_online():
    """Run migrations in 'online' mode.

    In this scenario we need to create an Engine
    and associate a connection with the context.

    """
    engine = engine_from_config(settings, prefix='sqlalchemy.')

    connection = engine.connect()
    context.configure(
        connection=connection,
        target_metadata=target_metadata
    )

    try:
        with context.begin_transaction():
            context.run_migrations()
    finally:
        connection.close()


if context.is_offline_mode():
    run_migrations_offline()
else:
    run_migrations_online()

```

## File: `ruangpulih\alembic\script.py.mako`

```
"""${message}

Revision ID: ${up_revision}
Revises: ${down_revision | comma,n}
Create Date: ${create_date}

"""
from alembic import op
import sqlalchemy as sa
${imports if imports else ""}

# revision identifiers, used by Alembic.
revision = ${repr(up_revision)}
down_revision = ${repr(down_revision)}
branch_labels = ${repr(branch_labels)}
depends_on = ${repr(depends_on)}


def upgrade():
    ${upgrades if upgrades else "pass"}


def downgrade():
    ${downgrades if downgrades else "pass"}

```

## File: `ruangpulih\alembic\versions\20250524_0f0bff5f685f.py`

```
"""init kedua

Revision ID: 0f0bff5f685f
Revises: 88291d9da7f4
Create Date: 2025-05-24 13:22:05.103489

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '0f0bff5f685f'
down_revision = '88291d9da7f4'
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    pass
    # ### end Alembic commands ###

```

## File: `ruangpulih\alembic\versions\20250524_88291d9da7f4.py`

```
"""Initial schema setup with SQLAlchemy Enum for User role

Revision ID: 88291d9da7f4
Revises:
Create Date: 2025-05-24 12:02:10.024630

"""
from alembic import op
import sqlalchemy as sa


# revision identifiers, used by Alembic.
revision = '88291d9da7f4'
down_revision = None
branch_labels = None
depends_on = None


def upgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.create_table('users',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('username', sa.String(), nullable=False),
    sa.Column('email', sa.String(), nullable=False),
    sa.Column('password', sa.String(), nullable=False),
    sa.Column('role', sa.Enum('client', 'psychologist', name='role_enum'), nullable=False),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_users')),
    sa.UniqueConstraint('email', name=op.f('uq_users_email')),
    sa.UniqueConstraint('username', name=op.f('uq_users_username'))
    )
    op.create_table('schedules',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('psychologist_id', sa.String(), nullable=True),
    sa.Column('date', sa.Date(), nullable=False),
    sa.Column('time_slot', sa.Time(), nullable=False),
    sa.Column('is_booked', sa.Boolean(), nullable=True),
    sa.ForeignKeyConstraint(['psychologist_id'], ['users.id'], name=op.f('fk_schedules_psychologist_id_users')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_schedules'))
    )
    op.create_table('bookings',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('client_id', sa.String(), nullable=True),
    sa.Column('schedule_id', sa.String(), nullable=True),
    sa.Column('status', sa.Enum('pending', 'confirmed', 'rejected', name='booking_status'), nullable=True),
    sa.Column('created_at', sa.DateTime(), nullable=True),
    sa.ForeignKeyConstraint(['client_id'], ['users.id'], name=op.f('fk_bookings_client_id_users')),
    sa.ForeignKeyConstraint(['schedule_id'], ['schedules.id'], name=op.f('fk_bookings_schedule_id_schedules')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_bookings'))
    )
    op.create_table('reviews',
    sa.Column('id', sa.String(), nullable=False),
    sa.Column('booking_id', sa.String(), nullable=False),
    sa.Column('rating', sa.Integer(), nullable=False),
    sa.Column('comment', sa.Text(), nullable=True),
    sa.ForeignKeyConstraint(['booking_id'], ['bookings.id'], name=op.f('fk_reviews_booking_id_bookings')),
    sa.PrimaryKeyConstraint('id', name=op.f('pk_reviews'))
    )
    # ### end Alembic commands ###


def downgrade():
    # ### commands auto generated by Alembic - please adjust! ###
    op.drop_table('reviews')
    op.drop_table('bookings')
    op.drop_table('schedules')
    op.drop_table('users')
    # ### end Alembic commands ###

```

## File: `ruangpulih\alembic\versions\README.txt`

```
Placeholder for alembic versions
```

## File: `ruangpulih\models\booking.py`

```
import uuid
from datetime import datetime
from sqlalchemy import Column, String, Enum, ForeignKey, DateTime
from sqlalchemy.orm import relationship
from .meta import Base

class Booking(Base):
    __tablename__ = 'bookings'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    client_id = Column(String, ForeignKey('users.id'))
    schedule_id = Column(String, ForeignKey('schedules.id'))
    status = Column(Enum("pending", "confirmed", "rejected", name="booking_status"), default="pending")
    created_at = Column(DateTime, default=datetime.utcnow)

    client = relationship("User", back_populates="bookings")
    schedule = relationship("Schedule", back_populates="bookings")

    def to_dict(self):
        data = {
            "id": self.id,
            "client_id": self.client_id,
            "schedule_id": self.schedule_id,
            "status": self.status,
            "created_at": self.created_at.isoformat() if self.created_at else None
        }

        if self.client:
            data['client_details'] = self.client.to_dict()

        return data

    def __repr__(self):
        return (
            f"<Booking(id='{self.id}', client_id='{self.client_id}', "
            f"schedule_id='{self.schedule_id}', status='{self.status}')>"
        )

```

## File: `ruangpulih\models\meta.py`

```
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.schema import MetaData

# Recommended naming convention used by Alembic, as various different database
# providers will autogenerate vastly different names making migrations more
# difficult. See: http://alembic.zzzcomputing.com/en/latest/naming.html
NAMING_CONVENTION = {
    "ix": "ix_%(column_0_label)s",
    "uq": "uq_%(table_name)s_%(column_0_name)s",
    "ck": "ck_%(table_name)s_%(constraint_name)s",
    "fk": "fk_%(table_name)s_%(column_0_name)s_%(referred_table_name)s",
    "pk": "pk_%(table_name)s"
}

metadata = MetaData(naming_convention=NAMING_CONVENTION)
Base = declarative_base(metadata=metadata)

```

## File: `ruangpulih\models\review.py`

```
import uuid
from sqlalchemy import Column, String, Text, ForeignKey, Integer
from sqlalchemy.orm import relationship
from .meta import Base

class Review(Base):
    __tablename__ = 'reviews'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    booking_id = Column(String, ForeignKey('bookings.id'), nullable=False)
    rating = Column(Integer, nullable=False)
    comment = Column(Text)

    booking = relationship("Booking")

    def to_dict(self):
        return {
            "id": self.id,
            "booking_id": self.booking_id,
            "rating": self.rating,
            "comment": self.comment
        }

    def __repr__(self):
        return (
            f"<Review(id='{self.id}', booking_id='{self.booking_id}', "
            f"rating='{self.rating}')>"
        )

```

## File: `ruangpulih\models\schedule.py`

```
import uuid
from sqlalchemy import Column, String, Date, Time, Boolean, ForeignKey
from sqlalchemy.orm import relationship
from datetime import datetime
from .meta import Base

class Schedule(Base):
    __tablename__ = 'schedules'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    psychologist_id = Column(String, ForeignKey('users.id'))
    date = Column(Date, nullable=False)
    time_slot = Column(Time, nullable=False)
    is_booked = Column(Boolean, default=False)

    psychologist = relationship("User", back_populates="schedules")
    bookings = relationship("Booking", back_populates="schedule", uselist=True, cascade="all, delete-orphan")

    def to_dict(self):
        data = {
            "id": self.id,
            "psychologist_id": self.psychologist_id,
            "date": self.date.isoformat(),
            "time_slot": self.time_slot.strftime('%H:%M'),
            "is_booked": self.is_booked
        }

        # Find the current active booking if the schedule is booked.
        # This assumes a schedule typically has one 'active' booking at a time.
        # You might need to refine the filtering logic if there are multiple bookings
        # and you need a specific one (e.g., 'confirmed' status, or latest).
        current_booking = None
        if self.is_booked and self.bookings:
            current_booking = next((b for b in self.bookings if b.status == 'confirmed'), None)
            if not current_booking:
                current_booking = self.bookings[0]

        if current_booking:
            data['current_booking'] = current_booking.to_dict()

        return data

    def __repr__(self):
        return (
            f"<Schedule(id='{self.id}', psychologist_id='{self.psychologist_id}', "
            f"date='{self.date}', time_slot='{self.time_slot}', booked={self.is_booked})>"
        )

```

## File: `ruangpulih\models\user.py`

```
import uuid
from sqlalchemy import Column, String, Enum
from sqlalchemy.orm import relationship
from passlib.hash import bcrypt
from .meta import Base

class User(Base):
    __tablename__ = 'users'

    id = Column(String, primary_key=True, default=lambda: str(uuid.uuid4()))
    username = Column(String, nullable=False, unique=True)
    email = Column(String, nullable=False, unique=True)
    password = Column(String, nullable=False)

    role = Column(
        Enum("client", "psychologist", name="role_enum"),
        nullable=False
    )

    schedules = relationship("Schedule", back_populates="psychologist")
    bookings = relationship("Booking", back_populates="client")

    def set_password(self, raw_password):
        self.password = bcrypt.hash(raw_password)

    def check_password(self, raw_password):
        return bcrypt.verify(raw_password, self.password)

    def to_dict(self):
        return {
            "id": self.id,
            "username": self.username,
            "email": self.email,
            "role": self.role
        }

    def __repr__(self):
        return f"<User(username='{self.username}', email='{self.email}', role='{self.role}')>"

```

## File: `ruangpulih\models\__init__.py`

```
from sqlalchemy import engine_from_config
from sqlalchemy.orm import sessionmaker
from sqlalchemy.orm import configure_mappers
import zope.sqlalchemy

# Import all models to ensure they are attached to the Base.metadata
from .booking import Booking
from .review import Review
from .schedule import Schedule
from .user import User

# Run configure_mappers after defining all models to ensure relationships are set up
configure_mappers()

def get_engine(settings, prefix='sqlalchemy.'):
    return engine_from_config(settings, prefix)

def get_session_factory(engine):
    factory = sessionmaker()
    factory.configure(bind=engine)
    return factory

def get_tm_session(session_factory, transaction_manager):
    """
    Get a ``sqlalchemy.orm.Session`` instance backed by a transaction.

    This function will hook the session to the transaction manager which
    will take care of committing any changes.

    - When using pyramid_tm it will automatically be committed or aborted
      depending on whether an exception is raised.

    - When using scripts you should wrap the session in a manager yourself.
      For example::

          import transaction

          engine = get_engine(settings)
          session_factory = get_session_factory(engine)
          with transaction.manager:
              dbsession = get_tm_session(session_factory, transaction.manager)
    """
    dbsession = session_factory()
    zope.sqlalchemy.register(
        dbsession, transaction_manager=transaction_manager)
    return dbsession

def includeme(config):
    """
    Initialize the model for a Pyramid app.

    Activate this setup using ``config.include('ruangpulih.models')``.
    """
    settings = config.get_settings()
    settings['tm.manager_hook'] = 'pyramid_tm.explicit_manager'

    config.include('pyramid_tm')
    config.include('pyramid_retry')

    session_factory = get_session_factory(get_engine(settings))
    config.registry['dbsession_factory'] = session_factory

    config.add_request_method(
        lambda r: get_tm_session(session_factory, r.tm),
        'dbsession',
        reify=True
    )

```

## File: `ruangpulih\scripts\initialize_db.py`

```
import os
import argparse
import sys
import transaction
import uuid
from datetime import datetime, date, time

from pyramid.paster import bootstrap, setup_logging
from sqlalchemy.exc import OperationalError

from .. import models
from ..models.meta import Base
from ..models.user import User
from ..models.schedule import Schedule
from ..models.booking import Booking
from ..models.review import Review

def setup_models(dbsession):
    """
    Initializes database tables and adds dummy data.
    """
    print("Creating all tables based on models...")
    Base.metadata.create_all(dbsession.bind)
    print("Tables successfully created.")

    print("Adding dummy data...")

    # 1. Users (Psychologists and Clients)
    psychologist_lisa = User(
        id=str(uuid.uuid4()),
        username="dr.lisa",
        email="lisa@ruangpulih.com",
        role="psychologist"
    )
    psychologist_lisa.set_password("passwordlisa")
    dbsession.add(psychologist_lisa)

    psychologist_budi = User(
        id=str(uuid.uuid4()),
        username="dr.budi",
        email="budi@ruangpulih.com",
        role="psychologist"
    )
    psychologist_budi.set_password("passwordbudi")
    dbsession.add(psychologist_budi)

    client_ali = User(
        id=str(uuid.uuid4()),
        username="ali_client",
        email="ali@example.com",
        role="client"
    )
    client_ali.set_password("passwordali")
    dbsession.add(client_ali)

    client_bina = User(
        id=str(uuid.uuid4()),
        username="bina_client",
        email="bina@example.com",
        role="client"
    )
    client_bina.set_password("passwordbina")
    dbsession.add(client_bina)

    dbsession.flush()

    # 2. Schedules
    schedule_lisa_1 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_lisa.id,
        date=date(2025, 6, 1),
        time_slot=time(9, 0),
        is_booked=False
    )
    dbsession.add(schedule_lisa_1)

    schedule_lisa_2 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_lisa.id,
        date=date(2025, 6, 1),
        time_slot=time(10, 0),
        is_booked=False
    )
    dbsession.add(schedule_lisa_2)

    schedule_budi_1 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_budi.id,
        date=date(2025, 6, 2),
        time_slot=time(14, 0),
        is_booked=False
    )
    dbsession.add(schedule_budi_1)

    schedule_budi_2 = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=psychologist_budi.id,
        date=date(2025, 6, 2),
        time_slot=time(15, 0),
        is_booked=False
    )
    dbsession.add(schedule_budi_2)

    dbsession.flush()

    # 3. Bookings
    booking_ali_lisa = Booking(
        id=str(uuid.uuid4()),
        client_id=client_ali.id,
        schedule_id=schedule_lisa_1.id,
        status="confirmed",
        created_at=datetime.utcnow()
    )
    dbsession.add(booking_ali_lisa)
    schedule_lisa_1.is_booked = True

    booking_bina_budi = Booking(
        id=str(uuid.uuid4()),
        client_id=client_bina.id,
        schedule_id=schedule_budi_1.id,
        status="pending",
        created_at=datetime.utcnow()
    )
    dbsession.add(booking_bina_budi)
    schedule_budi_1.is_booked = True

    dbsession.flush()

    # 4. Reviews
    review_ali = Review(
        id=str(uuid.uuid4()),
        booking_id=booking_ali_lisa.id,
        rating=5,
        comment="Sesi yang sangat membantu dan insightful. Terima kasih dr. Lisa!"
    )
    dbsession.add(review_ali)

    print("Dummy data successfully added.")


def parse_args(argv):
    parser = argparse.ArgumentParser()
    parser.add_argument(
        'config_uri',
        help='Configuration file, e.g., development.ini',
    )
    return parser.parse_args(argv[1:])


def main(argv=sys.argv):
    args = parse_args(argv)
    setup_logging(args.config_uri)
    env = bootstrap(args.config_uri)

    try:
        with env['request'].tm:
            dbsession = env['request'].dbsession
            setup_models(dbsession)
            transaction.commit()
            print("Database initialization complete.")
    except OperationalError:
        print('''
Pyramid is having a problem using your SQL database. The problem
might be caused by one of the following things:

1.  You may need to initialize your database tables with `alembic upgrade head`.
    This script (`initialize_db.py`) is for initial data population
    after the schema is created by Alembic.

2.  Your database server may not be running. Check that the
    database server referred to by the "sqlalchemy.url" setting in
    your "development.ini" file is running.
        ''')
        sys.exit(1)
    except Exception as e:
        print(f"An error occurred during database initialization: {e}")
        transaction.abort()
        sys.exit(1)

```

## File: `ruangpulih\scripts\__init__.py`

```
# package

```

## File: `ruangpulih\static\theme.css`

```
@import url(//fonts.googleapis.com/css?family=Open+Sans:300,400,600,700);
body {
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-weight: 300;
  color: #ffffff;
  background: #bc2131;
}
h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
  font-weight: 300;
}
p {
  font-weight: 300;
}
.font-normal {
  font-weight: 400;
}
.font-semi-bold {
  font-weight: 600;
}
.font-bold {
  font-weight: 700;
}
.starter-template {
  margin-top: 250px;
}
.starter-template .content {
  margin-left: 10px;
}
.starter-template .content h1 {
  margin-top: 10px;
  font-size: 60px;
}
.starter-template .content h1 .smaller {
  font-size: 40px;
  color: #f2b7bd;
}
.starter-template .content .lead {
  font-size: 25px;
  color: #f2b7bd;
}
.starter-template .content .lead .font-normal {
  color: #ffffff;
}
.starter-template .links {
  float: right;
  right: 0;
  margin-top: 125px;
}
.starter-template .links ul {
  display: block;
  padding: 0;
  margin: 0;
}
.starter-template .links ul li {
  list-style: none;
  display: inline;
  margin: 0 10px;
}
.starter-template .links ul li:first-child {
  margin-left: 0;
}
.starter-template .links ul li:last-child {
  margin-right: 0;
}
.starter-template .links ul li.current-version {
  color: #f2b7bd;
  font-weight: 400;
}
.starter-template .links ul li a, a {
  color: #f2b7bd;
  text-decoration: underline;
}
.starter-template .links ul li a:hover, a:hover {
  color: #ffffff;
  text-decoration: underline;
}
.starter-template .links ul li .icon-muted {
  color: #eb8b95;
  margin-right: 5px;
}
.starter-template .links ul li:hover .icon-muted {
  color: #ffffff;
}
.starter-template .copyright {
  margin-top: 10px;
  font-size: 0.9em;
  color: #f2b7bd;
  text-transform: lowercase;
  float: right;
  right: 0;
}
@media (max-width: 1199px) {
  .starter-template .content h1 {
    font-size: 45px;
  }
  .starter-template .content h1 .smaller {
    font-size: 30px;
  }
  .starter-template .content .lead {
    font-size: 20px;
  }
}
@media (max-width: 991px) {
  .starter-template {
    margin-top: 0;
  }
  .starter-template .logo {
    margin: 40px auto;
  }
  .starter-template .content {
    margin-left: 0;
    text-align: center;
  }
  .starter-template .content h1 {
    margin-bottom: 20px;
  }
  .starter-template .links {
    float: none;
    text-align: center;
    margin-top: 60px;
  }
  .starter-template .copyright {
    float: none;
    text-align: center;
  }
}
@media (max-width: 767px) {
  .starter-template .content h1 .smaller {
    font-size: 25px;
    display: block;
  }
  .starter-template .content .lead {
    font-size: 16px;
  }
  .starter-template .links {
    margin-top: 40px;
  }
  .starter-template .links ul li {
    display: block;
    margin: 0;
  }
  .starter-template .links ul li .icon-muted {
    display: none;
  }
  .starter-template .copyright {
    margin-top: 20px;
  }
}

```

## File: `ruangpulih\templates\404.jinja2`

```
{% extends "layout.jinja2" %}

{% block content %}
<div class="content">
  <h1><span class="font-semi-bold">Pyramid</span> <span class="smaller">Alchemy scaffold</span></h1>
  <p class="lead"><span class="font-semi-bold">404</span> Page Not Found</p>
</div>
{% endblock content %}

```

## File: `ruangpulih\templates\layout.jinja2`

```
<!DOCTYPE html>
<html lang="{{request.locale_name}}">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="pyramid web application">
    <meta name="author" content="Pylons Project">
    <link rel="shortcut icon" href="{{request.static_url('ruangpulih:static/pyramid-16x16.png')}}">

    <title>Cookiecutter Alchemy project for the Pyramid Web Framework</title>

    <!-- Bootstrap core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">

    <!-- Custom styles for this scaffold -->
    <link href="{{request.static_url('ruangpulih:static/theme.css')}}" rel="stylesheet">

    <!-- HTML5 shiv and Respond.js IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js" integrity="sha384-0s5Pv64cNZJieYFkXYOTId2HMA2Lfb6q2nAcx2n0RTLUnCAoTTsS0nKEO27XyKcY" crossorigin="anonymous"></script>
      <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js" integrity="sha384-ZoaMbDF+4LeFxg6WdScQ9nnR1QC2MIRxA1O9KWEXQwns1G8UNyIEZIQidzb0T1fo" crossorigin="anonymous"></script>
    <![endif]-->
  </head>

  <body>

    <div class="starter-template">
      <div class="container">
        <div class="row">
          <div class="col-md-2">
            <img class="logo img-responsive" src="{{request.static_url('ruangpulih:static/pyramid.png') }}" alt="pyramid web framework">
          </div>
          <div class="col-md-10">
            {% block content %}
                <p>No content</p>
            {% endblock content %}
          </div>
        </div>
        <div class="row">
          <div class="links">
            <ul>
              <li><i class="glyphicon glyphicon-cog icon-muted"></i><a href="https://github.com/Pylons/pyramid">Github Project</a></li>
              <li><i class="glyphicon glyphicon-globe icon-muted"></i><a href="https://webchat.freenode.net/?channels=pyramid">IRC Channel</a></li>
              <li><i class="glyphicon glyphicon-home icon-muted"></i><a href="https://pylonsproject.org">Pylons Project</a></li>
            </ul>
          </div>
        </div>
        <div class="row">
          <div class="copyright">
            Copyright &copy; Pylons Project
          </div>
        </div>
      </div>
    </div>


    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="//code.jquery.com/jquery-1.12.4.min.js" integrity="sha256-ZosEbRLbNQzLpnKIkEdrPv7lOy9C27hHQ+Xp8a4MxAQ=" crossorigin="anonymous"></script>
    <script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>
  </body>
</html>

```

## File: `ruangpulih\templates\mytemplate.jinja2`

```
{% extends "layout.jinja2" %}

{% block content %}
<div class="content">
  <h1><span class="font-semi-bold">Pyramid</span> <span class="smaller">Alchemy project</span></h1>
  <p class="lead">Welcome to <span class="font-normal">{{project}}</span>, a&nbsp;Pyramid application generated&nbsp;by<br><span class="font-normal">Cookiecutter</span>.</p>
</div>
{% endblock content %}
```

## File: `ruangpulih\views\auth.py`

```
from pyramid.view import view_config
from pyramid.response import Response
from pyramid.httpexceptions import HTTPBadRequest, HTTPConflict, HTTPUnauthorized
from pyramid.security import remember, forget
from ..models.user import User
from uuid import uuid4

def require_fields(data, required_fields):
    """Helper function to validate required fields in request data."""
    missing = [f for f in required_fields if not data.get(f)]
    if missing:
        raise HTTPBadRequest(json_body={'error': f'Missing fields: {", ".join(missing)}'})

@view_config(route_name='register', request_method='POST', renderer='json')
def register(request):
    """Handles new user registration."""
    data = request.json_body

    try:
        require_fields(data, ['username', 'email', 'password', 'role'])
    except HTTPBadRequest as e:
        return e

    username = data['username']
    email = data['email']
    password = data['password']
    role_str = data['role']

    valid_roles = ["client", "psychologist"]
    if role_str not in valid_roles:
        return HTTPBadRequest(json_body={'error': f'Invalid role: {role_str}. Valid roles are: {", ".join(valid_roles)}'})

    if request.dbsession.query(User).filter_by(username=username).first():
        return HTTPConflict(json_body={'error': 'Username already exists'})
    if request.dbsession.query(User).filter_by(email=email).first():
        return HTTPConflict(json_body={'error': 'Email already exists'})

    new_user = User(
        id=str(uuid4()),
        username=username,
        email=email,
        role=role_str
    )

    new_user.set_password(password)
    request.dbsession.add(new_user)

    return {
        'message': 'Registration successful',
        'user': new_user.to_dict()
    }

@view_config(route_name='login', request_method='POST', renderer='json')
def login(request):
    """Handles user login."""
    data = request.json_body

    try:
        require_fields(data, ['email', 'password'])
    except HTTPBadRequest as e:
        return e

    email = data['email']
    password = data['password']
    user = request.dbsession.query(User).filter_by(email=email).first()

    if not user or not user.check_password(password):
        return HTTPUnauthorized(json_body={'error': 'Invalid credentials'})

    headers = remember(request, user.id)

    return Response(
        json_body={
            'message': 'Login successful',
            'user': user.to_dict()
        },
        headers=headers,
        content_type='application/json'
    )

@view_config(route_name='logout', request_method='POST', renderer='json')
def logout(request):
    """Handles user logout."""
    headers = forget(request)
    return Response(
        json_body={'message': 'Logout successful'},
        headers=headers,
        content_type='application/json'
    )

```

## File: `ruangpulih\views\bookings.py`

```
from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized, HTTPNotFound
from pyramid.view import view_config
from sqlalchemy.orm import joinedload
from ..models.booking import Booking
from ..models.schedule import Schedule
from ..models.user import User
import uuid
from datetime import datetime

def get_user_id(request):
    """Extracts and validates the authenticated user ID from the request."""
    user_id = request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json_body={"error": "Unauthorized"})
    return user_id

def get_schedule_or_404(request, schedule_id):
    """Fetches a schedule by ID or raises HTTPNotFound."""
    schedule = request.dbsession.get(Schedule, schedule_id)
    if not schedule:
        raise HTTPNotFound(json_body={"error": "Schedule not found"})
    return schedule

@view_config(route_name='bookings', request_method='GET', renderer='json')
def list_bookings(request):
    """
    Lists bookings based on the authenticated user's role.
    Clients see their own bookings.
    Psychologists see bookings for their schedules.
    """
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    bookings_query = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    )

    if user.role == 'client':
        bookings_query = bookings_query.filter(Booking.client_id == user_id)
    elif user.role == 'psychologist':
        bookings_query = bookings_query.join(Schedule).filter(Schedule.psychologist_id == user_id)
    else:
        raise HTTPUnauthorized(json_body={"error": "Access denied for this role"})

    bookings = bookings_query.all()
    return [b.to_dict() for b in bookings]

@view_config(route_name='bookings', request_method='POST', renderer='json')
def create_booking(request):
    """Allows clients to create a new booking for an available schedule."""
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    if not user or user.role != 'client':
        raise HTTPUnauthorized(json_body={"error": "Only clients can create bookings"})

    data = request.json_body
    schedule_id = data.get("schedule_id")

    schedule = request.dbsession.query(Schedule).options(
        joinedload(Schedule.bookings)
    ).get(schedule_id)

    if not schedule:
        raise HTTPNotFound(json_body={"error": "Schedule not found"})

    if schedule.is_booked:
        raise HTTPBadRequest(json_body={"error": "Schedule already booked"})

    booking = Booking(
        id=str(uuid.uuid4()),
        client_id=user_id,
        schedule_id=schedule_id,
        status="pending",
        created_at=datetime.utcnow()
    )

    schedule.is_booked = True

    request.dbsession.add(booking)
    request.dbsession.flush()

    created_booking = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking.id)

    return created_booking.to_dict()

@view_config(route_name='booking_detail', request_method='GET', renderer='json')
def get_booking(request):
    """
    Retrieves details of a specific booking.
    Authorization: Clients can view their own, psychologists can view bookings for their schedules.
    """
    booking_id = request.matchdict['id']
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    booking = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking_id)

    if not booking:
        raise HTTPNotFound(json_body={"error": "Booking not found"})

    if user.role == 'client' and booking.client_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to view this booking"})
    elif user.role == 'psychologist' and booking.schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to view this booking"})

    return booking.to_dict()

@view_config(route_name='booking_detail', request_method='PUT', renderer='json')
@view_config(route_name='booking_detail', request_method='PATCH', renderer='json')
def update_booking_status(request):
    """
    Updates the status of a booking.
    Authorization: Clients can cancel their own bookings.
    Psychologists can confirm/reject bookings for their schedules.
    """
    booking_id = request.matchdict['id']
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    booking = request.dbsession.query(Booking).options(
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking_id)

    if not booking:
        raise HTTPNotFound(json_body={"error": "Booking not found"})

    new_status = request.json_body.get('status')
    if not new_status:
        raise HTTPBadRequest(json_body={"error": "Status field is required."})

    if user.role == 'client':
        if booking.client_id != user_id:
            raise HTTPUnauthorized(json_body={"error": "You do not have permission to modify this booking"})

        if new_status != "rejected":
            raise HTTPBadRequest(json_body={"error": "Clients can only cancel their bookings (set status to 'rejected')."})

        if booking.status != 'pending':
            raise HTTPBadRequest(json_body={"error": "Only pending bookings can be cancelled by clients."})

    elif user.role == 'psychologist':
        if booking.schedule.psychologist_id != user_id:
            raise HTTPUnauthorized(json_body={"error": "You do not have permission to modify this booking"})

        if new_status not in ["pending", "confirmed", "rejected"]:
            raise HTTPBadRequest(json_body={"error": "Invalid status provided."})

        if booking.status == 'confirmed' and new_status == 'pending':
            raise HTTPBadRequest(json_body={"error": "Cannot change confirmed booking back to pending."})
        if booking.status == 'rejected' and new_status != 'rejected':
            raise HTTPBadRequest(json_body={"error": "Cannot change rejected booking status."})
    else:
        raise HTTPUnauthorized(json_body={"error": "Access denied for this role"})

    booking.status = new_status

    if new_status == 'confirmed':
        booking.schedule.is_booked = True
    elif new_status == 'rejected':
        booking.schedule.is_booked = False
    elif new_status == 'pending' and not booking.schedule.is_booked:
        booking.schedule.is_booked = True

    request.dbsession.flush()

    updated_booking = request.dbsession.query(Booking).options(
        joinedload(Booking.client),
        joinedload(Booking.schedule).joinedload(Schedule.psychologist)
    ).get(booking_id)

    return updated_booking.to_dict()

@view_config(route_name='booking_detail', request_method='DELETE', renderer='json')
def delete_booking(request):
    """
    Deletes a booking.
    Authorization: Clients can delete their own bookings.
    Psychologists can delete any booking on their schedules.
    """
    booking_id = request.matchdict['id']
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    booking = request.dbsession.query(Booking).options(
        joinedload(Booking.schedule)
    ).get(booking_id)

    if not booking:
        raise HTTPNotFound(json_body={"error": "Booking not found"})

    if user.role == 'client' and booking.client_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to delete this booking"})
    elif user.role == 'psychologist' and booking.schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to delete this booking"})

    booking.schedule.is_booked = False

    request.dbsession.delete(booking)
    return {"message": "Booking deleted successfully"}

```

## File: `ruangpulih\views\default.py`

```
from pyramid.response import Response
from pyramid.view import view_config

@view_config(route_name='home')
def home_view(request):
    return Response('Ruang Pulih API Home', content_type='text/plain')

```

## File: `ruangpulih\views\notfound.py`

```
from pyramid.view import notfound_view_config


@notfound_view_config(renderer='../templates/404.jinja2')
def notfound_view(request):
    request.response.status = 404
    return {}

```

## File: `ruangpulih\views\pyschologist.py`

```
from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized, HTTPNotFound
from pyramid.view import view_config
from sqlalchemy.orm import joinedload, subqueryload
from sqlalchemy import and_, func
from ..models.user import User
from ..models.schedule import Schedule
from ..models.booking import Booking
from ..models.review import Review
from datetime import datetime, date, time

def psychologist_to_dict(psychologist, average_rating=None, total_reviews=None, available_schedules=None):
    """Helper function to format psychologist details into a dictionary."""
    data = {
        'id': str(psychologist.id),
        'username': psychologist.username,
        'email': psychologist.email,
        'role': psychologist.role,
        'average_rating': average_rating,
        'total_reviews': total_reviews,
    }
    if available_schedules is not None:
        data['available_schedules'] = available_schedules
    return data

def schedule_to_dict_simple(schedule):
    """Helper function to format schedule details simply."""
    return {
        'id': str(schedule.id),
        'date': schedule.date.isoformat(),
        'time_slot': schedule.time_slot.strftime('%H:%M'),
        'is_booked': schedule.is_booked,
    }

def review_to_dict_simple(review):
    """Helper function to format review details simply."""
    return {
        'id': str(review.id),
        'booking_id': review.booking_id,
        'rating': review.rating,
        'comment': review.comment,
    }

@view_config(route_name='psychologists_with_available_schedules', request_method='GET', renderer='json')
def get_psychologists_with_available_schedules(request):
    """
    Lists psychologists with their available (unbooked) schedules from today onwards.
    """
    today = datetime.utcnow().date()

    available_schedules_query = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist)
    ).filter(
        and_(
            Schedule.is_booked == False,
            Schedule.date >= today
        )
    ).order_by(
        Schedule.psychologist_id,
        Schedule.date,
        Schedule.time_slot
    )

    all_available_schedules = available_schedules_query.all()

    psychologists_data = {}
    for schedule in all_available_schedules:
        if schedule.psychologist:
            psychologist_id = str(schedule.psychologist.id)
            if psychologist_id not in psychologists_data:
                psychologists_data[psychologist_id] = psychologist_to_dict(schedule.psychologist)
                psychologists_data[psychologist_id]['available_schedules'] = []

            psychologists_data[psychologist_id]['available_schedules'].append(schedule_to_dict_simple(schedule))

    # Average rating and total reviews are not calculated here for the list view
    # as it might be performance-intensive for a large number of psychologists.
    # They are set to None/0 by default in psychologist_to_dict.
    return list(psychologists_data.values())

@view_config(route_name='psychologist_detail', request_method='GET', renderer='json')
def get_psychologist_detail(request):
    """
    Retrieves detailed information for a specific psychologist,
    including their available schedules and reviews.
    """
    psychologist_id = request.matchdict['id']

    psychologist = request.dbsession.query(User).filter(
        and_(User.id == psychologist_id, User.role == 'psychologist')
    ).first()

    if not psychologist:
        raise HTTPNotFound(json_body={"error": "Psychologist not found."})

    today = datetime.utcnow().date()
    available_schedules = request.dbsession.query(Schedule).filter(
        and_(
            Schedule.psychologist_id == psychologist_id,
            Schedule.is_booked == False,
            Schedule.date >= today
        )
    ).order_by(
        Schedule.date,
        Schedule.time_slot
    ).all()

    reviews_data = request.dbsession.query(Review).options(
        joinedload(Review.booking)
    ).join(Booking.schedule).filter(
        Schedule.psychologist_id == psychologist_id
    ).all()

    num_reviews = len(reviews_data)
    average_rating = round(sum(r.rating for r in reviews_data) / num_reviews, 1) if num_reviews > 0 else None

    psychologist_details = psychologist_to_dict(
        psychologist,
        average_rating=average_rating,
        total_reviews=num_reviews,
        available_schedules=[schedule_to_dict_simple(s) for s in available_schedules]
    )

    psychologist_details['reviews'] = [review_to_dict_simple(r) for r in reviews_data]

    return psychologist_details

```

## File: `ruangpulih\views\reviews.py`

```
from pyramid.view import view_config
from pyramid.httpexceptions import HTTPNotFound, HTTPUnauthorized
from ..models.review import Review
from ..models.booking import Booking
import uuid

def get_user_id(request):
    user_id = request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json_body={"error": "Unauthorized"})
    return user_id

@view_config(route_name='reviews', request_method='POST', renderer='json')
def create_review(request):
    user_id = get_user_id(request)
    data = request.json_body
    booking_id = data.get("booking_id")
    rating = data.get("rating")
    comment = data.get("comment", "")

    booking = request.dbsession.get(Booking, booking_id)
    if not booking or booking.client_id != user_id:
        raise HTTPNotFound(json_body={"error": "Booking not found or not yours"})

    review = Review(
        id=str(uuid.uuid4()),
        booking_id=booking_id,
        rating=rating,
        comment=comment
    )
    request.dbsession.add(review)
    return review.to_dict()

@view_config(route_name='reviews', request_method='GET', renderer='json')
def list_reviews(request):
    reviews = request.dbsession.query(Review).all()
    return [r.to_dict() for r in reviews]

```

## File: `ruangpulih\views\schedules.py`

```
# File: views/schedules.py
from pyramid.httpexceptions import HTTPBadRequest, HTTPUnauthorized, HTTPNotFound
from pyramid.view import view_config
from sqlalchemy.orm import joinedload
from ..models.schedule import Schedule
from ..models.user import User
from ..models.booking import Booking
import uuid
from datetime import datetime

def get_user_id(request):
    user_id = request.authenticated_userid
    if not user_id:
        raise HTTPUnauthorized(json_body={"error": "Unauthorized"})
    return user_id

def get_schedule_or_404(request, schedule_id):
    schedule = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist),
        joinedload(Schedule.bookings).joinedload(Booking.client)
    ).get(schedule_id)

    if not schedule:
        raise HTTPNotFound(json_body={"error": "Schedule not found"})
    return schedule

@view_config(route_name='schedules', request_method='GET', renderer='json')
def list_schedules(request):
    schedules_query = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist),
        joinedload(Schedule.bookings).joinedload(Booking.client)
    )

    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    if user.role == 'psychologist':
        schedules_query = schedules_query.filter(Schedule.psychologist_id == user_id)

    schedules = schedules_query.all()
    return [s.to_dict() for s in schedules]

@view_config(route_name='schedules', request_method='POST', renderer='json')
def add_schedule(request):
    user_id = get_user_id(request)
    user = request.dbsession.get(User, user_id)

    if not user or user.role != 'psychologist':
        raise HTTPUnauthorized(json_body={"error": "Only psychologists can create schedules"})

    data = request.json_body
    try:
        date = datetime.strptime(data.get("date"), "%Y-%m-%d").date()
        time_slot = datetime.strptime(data.get("time_slot"), "%H:%M").time()
    except Exception:
        raise HTTPBadRequest(json_body={"error": "Invalid date or time format (date=YYYY-MM-DD, time=HH:MM)"})

    new_schedule = Schedule(
        id=str(uuid.uuid4()),
        psychologist_id=user_id,
        date=date,
        time_slot=time_slot,
        is_booked=False
    )
    request.dbsession.add(new_schedule)
    request.dbsession.flush()

    created_schedule = request.dbsession.query(Schedule).options(
        joinedload(Schedule.psychologist),
        joinedload(Schedule.bookings).joinedload(Booking.client)
    ).get(new_schedule.id)

    return created_schedule.to_dict()

@view_config(route_name='schedule_detail', request_method='GET', renderer='json')
def get_schedule(request):
    schedule_id = request.matchdict['id']
    schedule = get_schedule_or_404(request, schedule_id)
    return schedule.to_dict()

@view_config(route_name='schedule_detail', request_method='PUT', renderer='json')
def update_schedule(request):
    schedule_id = request.matchdict['id']
    user_id = get_user_id(request)
    schedule = get_schedule_or_404(request, schedule_id)

    if schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to edit this schedule"})

    data = request.json_body
    try:
        if 'date' in data:
            schedule.date = datetime.strptime(data['date'], "%Y-%m-%d").date()
        if 'time_slot' in data:
            schedule.time_slot = datetime.strptime(data['time_slot'], "%H:%M").time()
    except Exception:
        raise HTTPBadRequest(json_body={"error": "Invalid date or time format (date=YYYY-MM-DD, time=HH:MM)"})

    return schedule.to_dict()

@view_config(route_name='schedule_detail', request_method='DELETE', renderer='json')
def delete_schedule(request):
    schedule_id = request.matchdict['id']
    user_id = get_user_id(request)
    schedule = get_schedule_or_404(request, schedule_id)

    if schedule.psychologist_id != user_id:
        raise HTTPUnauthorized(json_body={"error": "You do not have permission to delete this schedule"})

    if schedule.is_booked:
        raise HTTPBadRequest(json_body={"error": "Cannot delete schedule that has been booked"})

    request.dbsession.delete(schedule)
    return {"message": "Schedule deleted"}

```

## File: `ruangpulih\views\__init__.py`

```

```

## File: `ruangpulih\cors.py`

```
# In a file called tweens.py or in the main file
from pyramid.response import Response
from pyramid.httpexceptions import HTTPForbidden

def cors_tween_factory(handler, registry):
    def cors_tween(request):
        # Allow specific origin (not *)
        allowed_origin = 'http://localhost:5173'

        if request.method == 'OPTIONS':
            # Preflight response
            response = request.response
            response.headers['Access-Control-Allow-Origin'] = allowed_origin
            response.headers['Access-Control-Allow-Credentials'] = 'true'
            response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
            response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'
            response.headers['Access-Control-Max-Age'] = '3600'

            return response

        # Actual response
        response = handler(request)
        response.headers['Access-Control-Allow-Origin'] = allowed_origin
        response.headers['Access-Control-Allow-Credentials'] = 'true'
        response.headers['Access-Control-Allow-Methods'] = 'GET, POST, PUT, DELETE, OPTIONS'
        response.headers['Access-Control-Allow-Headers'] = 'Content-Type, Authorization'

        return response

    return cors_tween
```

## File: `ruangpulih\pshell.py`

```
from . import models

def setup(env):
    request = env['request']

    # start a transaction
    request.tm.begin()

    # inject some vars into the shell builtins
    env['tm'] = request.tm
    env['dbsession'] = request.dbsession
    env['models'] = models

```

## File: `ruangpulih\routes.py`

```
def includeme(config):
    config.add_static_view('static', 'static', cache_max_age=3600)
    config.add_route('home', '/')

    # Auth routes
    config.add_route('register', '/register')
    config.add_route('login', '/login')
    config.add_route('logout', '/logout')

    # Schedules routes
    config.add_route('schedules', '/schedules')                     # GET (list), POST (create)
    config.add_route('schedule_detail', '/schedules/{id}')          # GET (detail), PUT (update), DELETE (delete)

    # Bookings routes
    config.add_route('bookings', '/bookings')
    config.add_route('booking_detail', '/bookings/{id}')

    # Psychologists routes
    config.add_route('psychologists_with_available_schedules', '/psychologists/available')
    config.add_route('psychologist_detail', '/psychologists/{id}')

    # Reviews routes
    config.add_route('reviews', '/reviews')

```

## File: `ruangpulih\tests.py`

```
import unittest
import transaction

from pyramid import testing

def dummy_request(dbsession):
    return testing.DummyRequest(dbsession=dbsession)


class BaseTest(unittest.TestCase):
    def setUp(self):
        self.config = testing.setUp(settings={
            'sqlalchemy.url': 'sqlite:///:memory:'
        })
        self.config.include('.models')
        settings = self.config.get_settings()

        from .models import (
            get_engine,
            get_session_factory,
            get_tm_session,
            )

        self.engine = get_engine(settings)
        session_factory = get_session_factory(self.engine)

        self.session = get_tm_session(session_factory, transaction.manager)

    def init_database(self):
        from .models.meta import Base
        Base.metadata.create_all(self.engine)

    def tearDown(self):
        from .models.meta import Base

        testing.tearDown()
        transaction.abort()
        Base.metadata.drop_all(self.engine)


class TestMyViewSuccessCondition(BaseTest):

    def setUp(self):
        super(TestMyViewSuccessCondition, self).setUp()
        self.init_database()

        from .models import MyModel

        model = MyModel(name='one', value=55)
        self.session.add(model)

    def test_passing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info['one'].name, 'one')
        self.assertEqual(info['project'], 'ruangpulih')


class TestMyViewFailureCondition(BaseTest):

    def test_failing_view(self):
        from .views.default import my_view
        info = my_view(dummy_request(self.session))
        self.assertEqual(info.status_int, 500)

```

## File: `ruangpulih\__init__.py`

```
from pyramid.config import Configurator
from pyramid.authentication import AuthTktAuthenticationPolicy
from pyramid.authorization import ACLAuthorizationPolicy
from .cors import cors_tween_factory
from pyramid.renderers import JSON


def main(global_config, **settings):
    """ This function returns a Pyramid WSGI application. """
    # Set authentication and authorization policies
    authn_policy = AuthTktAuthenticationPolicy(
        secret='supersecretvalue',  # Ganti dengan nilai rahasia Anda
        callback=None,  # Tidak ada callback untuk group/role karena Anda tidak memakai role
        hashalg='sha512'
    )

    authz_policy = ACLAuthorizationPolicy()  # Untuk authorization dasar

    with Configurator(settings=settings) as config:
        config.set_authentication_policy(authn_policy)  # Set authentication policy
        config.set_authorization_policy(authz_policy)  # Set authorization policy

        config.add_tween('.cors_tween_factory')  # Add CORS tween
        config.add_renderer('json', JSON(indent=4))

        config.include('pyramid_jinja2')
        config.include('.models')
        config.include('.routes')

        config.scan()  # Memindai semua view-config

    return config.make_wsgi_app()

```
